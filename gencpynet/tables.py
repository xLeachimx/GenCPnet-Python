# File: tables.py
# Author: Michael Huelsman
# Copyright: Dr. Michael Andrew Huelsman 2025
# License: GNU GPLv3
# Created On: 10 Dec 2025
# Purpose:
#   A Python copy of tables.h and table.cc. Provides the cpnet_ccdf and cpnet_dist classes.
# Notes:
#   Removed rng seeding
#   MT Algorithm is already default for Python's built in random library.
#   Variable names have been modified for readability
#   Changed using integers for everything to boolean list, where applicable. This should
#       expand what can be generated by the program (assuming limits are removed elsewhere.)

import random

# Addtional functions

# Knuth's algorithm 3.4.2S: Select a subset of size n from a set of size N.
# Translator's note: Original relied on specifics of a bit string, converted to be more Pythonic
def random_k_subset(full_set: list[bool], subset_size: int) -> list[bool]:
    """
    An implementation of Knuth's algorithm 3.4.2S
    :param full_set: A list of booleans indicating whether or not that item is valid for selection.
    :param subset_size: The size of the subset to return.
    :return: Returns a list of booleans such that if full_set[i] and result[i] are True, then element
        i was selected.
    """
    set_size = sum(full_set)
    result = [False for _ in range(len(full_set))]
    traversed = 0
    selected = 0
    current_item = 0
    for idx in range(len(full_set)):
        if not full_set[idx]:
            #Skip elements which are not being considered.
            continue
        decider = random.uniform(0, 1.0)
        if ((set_size - traversed) * decider) < (subset_size - selected):
            result[current_item] = True
            selected += 1
        traversed += 1
        if selected == subset_size:
            # If done early break
            break
    return result


# Translators Note: 0 had means no hamming consideration.
def random_outcome_pair(n: int, hamming_dist: int) -> tuple[list[bool], list[bool]]:
    """
    Creates a binary pair or random outcomes with the specified hamming distance.
    :param n: The number of features.
    :param hamming_dist: The exact hamming distance between those outcomes.
        (0 indicates any hamming distance.)
    :return: A pair of boolean lists representing the outcomes.
    """
    first_outcome = [random.uniform(0, 1.0) < 0.5 for _ in range(n)]
    second_outcome = first_outcome[:]
    mask = None
    if hamming_dist > 0:
        mask = random_k_subset([True for _ in range(n)], hamming_dist)
    if mask is None:
        while second_outcome == first_outcome:
            second_outcome = [random.uniform(0, 1.0) < 0.5 for _ in range(n)]
    else:
        for idx, item in enumerate(mask):
            if item:
                second_outcome[idx] = not second_outcome[idx]
    return first_outcome, second_outcome


class CPnet_ccdf:
    def __init__(self, length: int, domain_size: int):
        self.__length = length
        self.__domain_size = domain_size
        self.__p = [0.0 for _ in range(length)]
        self.__s = [0 for _ in range(length)]
        self.__t = [0 for _ in range(length)]
        self.__row = 0

    def print(self):
        for idx in range(self.__length):
            print(f"{self.__p[idx]}\t{self.__s[idx]}\t{self.__t[idx]}")

    def write(self, file_handle):
        for idx in range(self.__length):
            print(self.__p[idx], self.__s[idx], self.__t[idx], file=file_handle)

    def read(self, file_handle):
        line = file_handle.read_line().strip().split()
        self.__p[self.__row] = float(line[0])
        self.__s[self.__row] = int(line[1])
        self.__t[self.__row] = int(line[2])

    # Selects a pair (s, t) iid from the distribution defined in the table
    def random_st(self) -> tuple[int, int]:
        decider = random.uniform(0.0, 1.0)
        for idx, prob in enumerate(self.__p):
            if decider > prob:
                return self.__s[idx], self.__t[idx]
        return self.__s[-1], self.__t[-1]

    # Returns a random node consisting of the values of (s, t) as well as a random CPT
    def random_node(self, n: int, q: int, U: int, A: int, cpt: list[int], j: int) -> tuple[int, int, list[int]]:
        pass
        s, t = self.random_st()
        cpt_size = self.__domain_size ** (s+t)
        # off to complete the rand_cpt function, pick on line 195 of tables.cc


class CPnet_dist:
    pass